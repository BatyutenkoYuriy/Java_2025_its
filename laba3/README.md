# Контрольні питання
## 1. Що таке структурне програмування?

Структурне програмування — це парадигма програмування, яка базується на використанні структурованих керуючих конструкцій та ієрархічної декомпозиції програми. Основна ідея полягає в тому, що програма повинна складатися з простих, логічно організованих блоків коду, які виконуються послідовно, умовно або циклічно.

## 2. Назвіть основні конструкції структурного програмування.

- **Послідовність** — виконання інструкцій одна за одною
- **Розгалуження** — умовні оператори (if-else, switch)
- **Цикли** — оператори повторення (while, do-while, for)
- **Підпрограми** — функції та методи

## 3. Назвіть основні принципи структурного програмування.

- **Принцип єдиного входу та виходу** — кожен блок коду має один вхід і один вихід
- **Використання тільки трьох основних конструкцій** — послідовність, розгалуження, цикл
- **Модульність** — розбиття програми на невеликі, зрозумілі модулі
- **Уникнення goto** — заборона на використання безумовних переходів
- **Проектування зверху-вниз** — поступова деталізація від загального до конкретного

## 4. Поясніть, чому в більшості мов програмування не радять використовувати оператор GOTO, а в мові Java його взагалі немає?

Оператор GOTO створює **спагеті-код** — заплутаний код з безладними переходами між різними частинами програми. Це призводить до:
- Погіршення читабельності коду
- Ускладнення відлагодження та тестування
- Порушення логічної структури програми
- Збільшення ймовірності помилок

Java повністю виключила GOTO, щоб забезпечити структурованість та читабельність коду. Замість цього Java надає структуровані конструкції керування потоком.

## 5. Що таке спагеті-код?

Спагеті-код — це жаргонний термін для опису коду, який має заплутану структуру керування з багатьма переходами, що робить його схожим на заплутану тарілку спагеті. Такий код важко читати, розуміти, підтримувати та модифікувати.

## 6. Що таке проектування зверху-вниз? В чому його переваги?

Проектування зверху-вниз — це методологія розробки, при якій спочатку визначається загальна структура програми, а потім поступово деталізуються окремі компоненти.

**Переваги:**
- Краща організація коду
- Легше розуміння загальної архітектури
- Можливість розпаралелити розробку
- Зменшення складності за рахунок поділу на підзадачі
- Покращена тестованість окремих модулів

## 7. Що таке область видимості ідентифікатора?

Область видимості ідентифікатора — це частина програми, в якій цей ідентифікатор (змінна, метод, клас) може бути використаний. У Java існують різні рівні видимості: локальна, класова, пакетна, загальна.

## 8. Що таке блок? Як блоки впливають на область видимості?

Блок — це група інструкцій, об'єднаних фігурними дужками `{}`. Блоки створюють локальну область видимості: змінні, оголошені всередині блоку, існують тільки в межах цього блоку та вкладених у нього блоків.

```java
{
    int x = 10; // x видима тільки в цьому блоці
    {
        int y = 20; // y видима тільки у вкладеному блоці
        // тут доступні і x, і y
    }
    // тут доступна тільки x
}
// тут ні x, ні y недоступні
```

## 9. Приклади використання умовних операторів та конструкцій:

### if
Використовується для простої перевірки однієї умови:
```java
if (age >= 18) {
    System.out.println("Повнолітній");
}
```

### if-else
Коли потрібно виконати одну з двох альтернатив:
```java
if (password.equals(correctPassword)) {
    login();
} else {
    showError();
}
```

### Ланцюги if-else if-else
Для перевірки множинних взаємовиключних умов:
```java
if (score >= 90) {
    grade = 'A';
} else if (score >= 80) {
    grade = 'B';
} else if (score >= 70) {
    grade = 'C';
} else {
    grade = 'F';
}
```

### switch
Для перевірки конкретних значень однієї змінної:
```java
switch (dayOfWeek) {
    case 1: dayName = "Понеділок"; break;
    case 2: dayName = "Вівторок"; break;
    case 3: dayName = "Середа"; break;
    default: dayName = "Невідомий день";
}
```

### Тернарна операція ?:
Для простого вибору між двома значеннями:
```java
String message = (isLoggedIn) ? "Ласкаво просимо!" : "Будь ласка, увійдіть";
int max = (a > b) ? a : b;
```

## 10. Приклади використання циклів:

### while
Коли кількість ітерацій заздалегідь невідома:
```java
while (scanner.hasNextLine()) {
    String line = scanner.nextLine();
    processLine(line);
}
```

### do-while
Коли потрібно виконати тіло циклу хоча б один раз:
```java
String input;
do {
    input = scanner.nextLine();
    System.out.println("Введіть 'exit' для виходу");
} while (!input.equals("exit"));
```

### for
Коли кількість ітерацій відома заздалегідь:
```java
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}

for (String item : collection) {
    processItem(item);
}
```

## 11. Чим оператор break відрізняється від оператора continue?

- **break** — повністю виходить з поточного циклу або switch-блоку
- **continue** — пропускає решту тіла поточної ітерації циклу та переходить до наступної ітерації

```java
for (int i = 1; i <= 10; i++) {
    if (i == 5) continue; // пропустити 5
    if (i == 8) break;    // зупинитися на 8
    System.out.println(i); // виведе: 1, 2, 3, 4, 6, 7
}
```

## 12. Навіщо у мові Java є мітки, якщо немає goto?

Мітки в Java використовуються з операторами break та continue для керування вкладеними циклами. Вони дозволяють вийти або продовжити зовнішній цикл з внутрішнього:

```java
outer: for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outer; // виходить з зовнішнього циклу
        }
        System.out.println(i + "," + j);
    }
}
```

## 13. Аналіз фрагменту коду з boolean:

```java
boolean a = false;
boolean b = false;
if (a=false) {           // Присвоєння! a стає false
    System.out.println("a is false");
}
if (b=true) {            // Присвоєння! b стає true
    System.out.println("b is true");
}
if (a=b) {               // Присвоєння! a стає true (значення b)
    System.out.println("a = b");
}
```

**Результат:**
```
b is true
a = b
```

**Пояснення:** Використовується оператор присвоєння `=` замість порівняння `==`. Перша умова `a=false` повертає false, друга `b=true` повертає true, третя `a=b` присвоює a значення true і повертає true.

## 14. Аналіз фрагменту коду з switch:

```java
int a = 1;
a++;          // a стає 2
++a;          // a стає 3
switch(a) {
    case 1: System.out.println("1");
    case 2: System.out.println("2");
    case 3: System.out.println("3");    // Починається тут
    case 4: System.out.println("4");
}
```

**Результат:**
```
3
4
```

**Пояснення:** Змінна `a` дорівнює 3. У switch відсутні break-и, тому після виконання case 3 програма "провалюється" до case 4.

## 15. Аналіз фрагменту коду з циклом:

```java
double sum = 0;
for(int i=1; i<10; i++) {
    sum = sum + 1/i;     // Цілочисельне ділення!
}
System.out.println(sum > 1);
```

**Результат:** `false`

**Пояснення:** Через цілочисельне ділення `1/i` завжди дорівнює 0 (крім i=1, де результат 1). Тому sum = 0 + 1 + 0 + 0 + ... = 1.0. Умова `1.0 > 1` є false.

**Для правильного результату потрібно:** `sum = sum + 1.0/i;` або `sum = sum + (double)1/i;`