# Контрольні питання

---

## 1. Різниця між ключовими та зарезервованими словами

**Ключові слова (Keywords)** — це слова, які мають спеціальне значення в Java і використовуються для визначення структури програми. Вони не можуть використовуватися як ідентифікатори.

**Зарезервовані слова (Reserved words)** — це слова, які зарезервовані для можливого майбутнього використання в Java, але поки що не мають функціональності.

**Приклади:**
- **Ключові слова:** `class`, `public`, `static`, `void`, `if`, `for`, `while`
- **Зарезервовані слова:** `goto`, `const`

---

## 2. Примітивні типи даних Java та їх застосування

| Тип | Розмір | Діапазон | Найкраще застосування |
|-----|--------|----------|----------------------|
| `byte` | 1 байт | -128 до 127 | Вік людини, рівень звуку |
| `short` | 2 байти | -32,768 до 32,767 | Кількість днів у році, температура |
| `int` | 4 байти | ≈ -2.1 млрд до 2.1 млрд | Рахунок у футболі, населення міста |
| `long` | 8 байт | ≈ -9.2×10¹⁸ до 9.2×10¹⁸ | Довжина файлу в байтах, кількість зірок |
| `float` | 4 байти | ≈ ±3.4×10³⁸ | Заробітна плата, відстані |
| `double` | 8 байт | ≈ ±1.8×10³⁰⁸ | Маса всесвіту, наукові розрахунки |
| `char` | 2 байти | 0 до 65,535 | Символи Unicode |
| `boolean` | 1 біт | true/false | Прапорці стану, логічні умови |

---

## 3. Знакові та беззнакові типи

В Java **всі цілочисельні типи є знаковими**, окрім `char`.

**Знакові типи:** `byte`, `short`, `int`, `long` — можуть зберігати від'ємні та додатні значення.

**Беззнаковий тип:** `char` — зберігає лише додатні значення (коди Unicode символів).

**Типи з плаваючою комою:** `float`, `double` — знакові за визначенням.

---

## 4. Максимальні значення цілочисельних типів

| Тип | Максимальне значення |
|-----|---------------------|
| `short` | 32,767 |
| `char` | 65,535 |
| `int` | 2,147,483,647 |
| `long` | 9,223,372,036,854,775,807 |

**Константи в Java:**
```java
System.out.println(Short.MAX_VALUE);    // 32767
System.out.println(Character.MAX_VALUE); // 65535
System.out.println(Integer.MAX_VALUE);   // 2147483647
System.out.println(Long.MAX_VALUE);      // 9223372036854775807
```

---

## 5. Діапазон типу byte (-128..127)

**Пояснення діапазону:**
- `byte` займає 8 біт
- Один біт відводиться під знак
- Залишається 7 біт для значення = 2⁷ = 128 варіантів

**Чому від'ємних більше:**
- Використовується **доповняльний код (two's complement)**
- 0 вважається додатним числом
- Тому: 128 від'ємних (-128..-1) та 128 додатних (0..127)

---

## 6. Системи числення та переведення

**Система числення** — це спосіб запису чисел за допомогою певного набору цифр.

**Основні системи:**
- **Десяткова (10):** цифри 0-9
- **Двійкова (2):** цифри 0-1
- **Вісімкова (8):** цифри 0-7  
- **Шістнадцяткова (16):** цифри 0-9, A-F

**Переведення з десяткової:**
```
25₁₀ → 11001₂ (ділимо на 2)
25₁₀ → 31₈ (ділимо на 8)
25₁₀ → 19₁₆ (ділимо на 16)
```

**В Java:**
```java
int decimal = 25;
System.out.println(Integer.toBinaryString(decimal));  // "11001"
System.out.println(Integer.toOctalString(decimal));   // "31"
System.out.println(Integer.toHexString(decimal));     // "19"
```

---

## 7. Доповняльний код (Two's Complement)

**Доповняльний код** — це спосіб представлення від'ємних чисел у двійковій системі.

**Алгоритм отримання:**
1. Взяти двійкове представлення додатного числа
2. Інвертувати всі біти (0→1, 1→0)
3. Додати 1

**Приклад для -5:**
```
5₁₀  = 00000101₂
Інверсія = 11111010₂
+1       = 11111011₂ = -5
```

**Переваги:**
- Однакова арифметика для додатних і від'ємних чисел
- Немає проблеми з "від'ємним нулем"

---

## 8. Аналіз переповнення int

```java
int a = 2_000_000_000;
int b = 2_000_000_000;
int c = a + b;
System.out.println(c); // Виведе: -294967296
```

**Пояснення:**
- `Integer.MAX_VALUE = 2,147,483,647`
- `a + b = 4,000,000,000` перевищує максимум
- Відбувається **переповнення (overflow)**
- Результат "обертається" до від'ємних значень
- Це поведінка доповняльного коду

**Рішення:** використовувати `long` або перевіряти на переповнення:
```java
long result = (long)a + b; // 4000000000
```

---

## 9. Різниця між float та double

| Характеристика | float | double |
|----------------|-------|--------|
| **Розмір** | 32 біти (4 байти) | 64 біти (8 байт) |
| **Точність** | ~7 десяткових цифр | ~15-17 десяткових цифр |
| **Діапазон** | ±3.4×10³⁸ | ±1.8×10³⁰⁸ |
| **За замовчуванням** | Потрібен суфікс `f` | Стандартний тип |

**Приклади:**
```java
float f = 3.14f;        // Обов'язковий суфікс f
double d = 3.14159265359; // Більша точність
```

---

## 10. Числа з плаваючою комою

**Число з плаваючою комою** — це спосіб представлення дійсних чисел у форматі **мантиса × основа^степінь**.

**Структура (стандарт IEEE 754):**
- **Знак:** 1 біт
- **Степінь:** 8 біт (float) / 11 біт (double)  
- **Мантиса:** 23 біти (float) / 52 біти (double)

**Приклад:** 12.375₁₀
```
12.375 = 1.1000110₂ × 2³
Знак: 0 (додатне)
Степінь: 3 + 127 = 130 (зміщена форма)
Мантиса: 1000110... (без старшого біта)
```

---

## 11. Double.NaN (Not a Number)

**Double.NaN** — спеціальне значення, що означає "не число".

**Коли з'являється:**
- Ділення нуля на нуль: `0.0 / 0.0`
- Квадратний корінь від'ємного числа: `Math.sqrt(-1)`
- Логарифм від'ємного числа: `Math.log(-1)`
- Операції з нескінченністю: `Double.POSITIVE_INFINITY - Double.POSITIVE_INFINITY`

**Приклад:**
```java
double nan = 0.0 / 0.0;
System.out.println(nan); // NaN
System.out.println(Double.isNaN(nan)); // true
```

---

## 12. Порівняння Double.NaN == Double.NaN

```java
System.out.println(Double.NaN == Double.NaN); // false
```

**Пояснення:**
- За стандартом IEEE 754, **NaN не дорівнює нічому, навіть самому собі**
- Це спеціальна властивість NaN
- Для перевірки на NaN використовують `Double.isNaN()`

**Правильна перевірка:**
```java
double value = 0.0 / 0.0;
if (Double.isNaN(value)) {
    System.out.println("Значення є NaN");
}
```

---

## 13. Преінкремент vs Постінкремент

**Преінкремент (++i):** спочатку збільшує, потім повертає нове значення  
**Постінкремент (i++):** спочатку повертає поточне значення, потім збільшує

**Приклади різних результатів:**
```java
int a = 5;
int b = 5;

int result1 = ++a * 2; // a=6, result1=12 (спочатку ++, потім *)
int result2 = b++ * 2; // b=6, result2=10 (спочатку *, потім ++)

System.out.println("a=" + a + ", result1=" + result1); // a=6, result1=12
System.out.println("b=" + b + ", result2=" + result2); // b=6, result2=10
```

**В циклах різниці немає:**
```java
for (int i = 0; i < 10; i++) { } // Те саме що
for (int i = 0; i < 10; ++i) { } // і це
```

---

## 14. Логічні vs Побітові операції AND

**Логічна операція AND:**
- `&&` (короткозамкнута): якщо перший операнд false, другий не обчислюється
- `&` (повна): завжди обчислює обидва операнди
- Працює з `boolean` значеннями

**Побітова операція AND:**
- `&`: виконує операцію AND для кожного біта
- Працює з цілими числами

**Приклади:**
```java
// Логічні операції
boolean result1 = false && someMethod(); // someMethod() НЕ викликається
boolean result2 = false & someMethod();  // someMethod() викликається

// Побітові операції  
int a = 5;  // 101₂
int b = 3;  // 011₂
int c = a & b; // 001₂ = 1
```

**Чому немає побітового &&:** короткозамкнутість не має сенсу для побітових операцій — потрібно обробити всі біти.

---

## 15. Різниця між OR та XOR

**OR (|, ||)** — "АБО": результат true, якщо принаймні один операнд true
**XOR (^)** — "Виключне АБО": результат true, якщо операнди різні

**Таблиці істинності:**

| A | B | A OR B | A XOR B |
|---|---|---------|---------|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 0 |

**Практичні приклади:**
```java
// Логічні операції
boolean a = true, b = false;
System.out.println(a | b);  // true (OR)
System.out.println(a ^ b);  // true (XOR)

boolean c = true, d = true;  
System.out.println(c | d);  // true (OR)
System.out.println(c ^ d);  // false (XOR) - різниця!

// Побітові операції
int x = 5; // 101₂
int y = 3; // 011₂
System.out.println(x | y); // 7 (111₂)
System.out.println(x ^ y); // 6 (110₂)
```

---

## 16. Аналіз складного логічного виразу

```java
boolean a = true && false | false;
System.out.println(a = false);
        
boolean b = true && false || false;
System.out.println(b = true);
```

**Покрокова розбивка:**

**Перший випадок:**
```java
boolean a = true && false | false;
```
- Пріоритет операцій: `&&` має вищий пріоритет за `|`
- `true && false` = `false`
- `false | false` = `false`
- `a = false`
- `System.out.println(a = false)` — **присвоєння в println!**
- Виведе: `false` (результат присвоєння)

**Другий випадок:**
```java
boolean b = true && false || false;
```
- Пріоритет операцій: `&&` має вищий пріоритет за `||`
- `true && false` = `false`
- `false || false` = `false`
- `b = false` (а не true, як написано в коментарі!)
- `System.out.println(b = true)` — **присвоєння в println!**
- Виведе: `true` (результат присвоєння)

**Важливо:** В `println` відбувається присвоєння (`=`), а не порівняння (`==`)!